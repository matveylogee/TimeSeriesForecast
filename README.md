# Прогнозирование временного ряда: потребление электроэнергии

Этот репозиторий содержит ноутбук **TimeSeriesForecast.ipynb** с решением задачи краткосрочного прогноза временного ряда.
Данные — потребление электроэнергии в Виктории (Австралия). В ряде выражены **суточная** и **недельная** сезонности.

## Кратко о задаче
- **Вход:** исторический ряд `value` (столбец в `data.csv`).
- **Выход:** прогноз на следующие **336** моментов времени после конца обучающей выборки.
- **Метрика:** RMSE.
- **Формат ответа:** файл `predictions.txt` (ровно 336 чисел, по одному в строку).

> Примечание по частоте: если данные почасовые — неделя это `p = 168` (24×7). Если получасовые — неделя это `p = 336` (48×7).

---

## Что делает ноутбук

### 1) Разделение данных
- Последние **336** наблюдений выделяются как **тест** для оценки качества (RMSE).
- Всё до них — **train** для построения шаблона и обучения простых моделей.

### 2) Выделение циклов и шаблонов (без признаков)
- Выбирается период **`p`** (обычно неделя: `168` для почасовых, `336` для получасовых).
- Train-ряд разбивается на целые циклы длиной `p`:
  ```python
  m = len(train) // p
  cycles = train[-m*p:].reshape(m, p)
  ```
- Строится **медианный шаблон цикла** `median_cycle = median(cycles, axis=0)` — это усреднённая «форма» недели.
- Для каждого цикла вычисляется **масштаб** (насколько цикл «выше/ниже» шаблона):
  ```python
  denom = median_cycle.copy(); denom[denom == 0] = 1e-6
  scales = median(cycles / denom, axis=1)   # размерность (m,)
  ```

### 3) Прогноз масштабов простыми моделями
Поскольку форма цикла фиксируется `median_cycle`, задача сводится к прогнозу **масштабов** на будущие `K_cycles = ceil(336 / p)` недель. В ноутбуке реализованы четыре быстрых подхода:

| Метод | Идея | Особенности |
|------:|:-----|:------------|
| **last** | повторяем последний оценённый масштаб | наивная опора на инерцию; хорош на очень коротком горизонте |
| **mean** | берём среднее по всем масштабам | устойчив к шуму, но «плоский», игнорирует тренды |
| **exp** | Simple Exponential Smoothing (SES) | больше весит свежие значения; параметр `alpha` управляет «реактивностью» |
| **ar** | авторегрессия AutoReg(p) | улавливает автокорреляцию; нужен выбор лагов `lags` |

Реализация (фрагменты):
```python
from statsmodels.tsa.holtwinters import SimpleExpSmoothing
from statsmodels.tsa.ar_model import AutoReg

def forecast_scales_last(scales, K): return np.array([scales[-1]] * K)
def forecast_scales_mean(scales, K): return np.array([np.mean(scales)] * K)

def forecast_scales_exp(scales, K, alpha=0.3):
    y = np.asarray(scales, dtype=float)
    fit = SimpleExpSmoothing(y, initialization_method="estimated").fit(
        smoothing_level=float(alpha), optimized=False
    )
    return np.asarray(fit.forecast(K), dtype=float)

def forecast_scales_ar(scales, K, lags=3):
    model = AutoReg(scales, lags=lags, old_names=False).fit()
    return model.predict(len(scales), len(scales) + K - 1)
```

### 4) Сборка финального прогноза
- Повторяем `median_cycle` на нужное число недель и умножаем построчно на предсказанные масштабы:
  ```python
  tile = np.tile(median_cycle, K_cycles).reshape(K_cycles, p)
  forecast_matrix = tile * pred_scales[:, None]
  forecast_full = forecast_matrix.flatten()[:horizon]
  ```

### 5) Оценка качества и график
- RMSE считается на тестовом хвосте из 336 точек для каждого метода, печатается отсортированная таблица.
- График выводится в виде **синяя линия** — «Train (последние 240)», **красная линия** — «Forecast (метод)».

---

## Гиперпараметры
- `p` — длина цикла (сутки/неделя). Для получасовых данных `p_day=48`, `p_week=336`; для почасовых — `24` и `168`.  
- `horizon` — горизонт прогноза, в задаче 336.
- `alpha` — параметр сглаживания SES (`exp`). Меньше — более «инерционный» прогноз; больше — более «реактивный».
- `lags` — порядок AR для масштабов (например, `3`, `24`, `48`).

---

## Результаты
При запуске ноутбук:
1. печатает RMSE для каждой из моделей (**last**, **mean**, **exp**, **ar**);
2. рисует график «Train (последние 240)» и «Forecast (метод)»;
3. сохраняет файл **`predictions.txt`** из 336 строк.

> Чем меньше RMSE, тем лучше модель. На практике простые baseline-ы «exp» и «ar» часто выигрывают у «last/mean» в условиях выраженной сезонности и инерции.
